package cn.com.wind.starter.log.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface
IgnoreResponseAdvice {

    /**
     * 是否进行全局异常处理封装
     * @return true:进行处理;  false:不进行异常处理
     */
    boolean errorDispose() default true;

}
package cn.com.wind.starter.log.annotation;

import java.lang.annotation.*;

import cn.com.wind.starter.log.enums.OperatorType;


/**
 * @author riven
 */
@Target({ ElementType.PARAMETER, ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Log{

    /**
     * 操作人类别
     */
    OperatorType operatorType() default OperatorType.MANAGE;




}


package cn.com.wind.starter.log.configuration;

import cn.com.wind.starter.log.handler.CommonResponseDataAdvice;
import cn.com.wind.starter.log.handler.GlobalDefaultExceptionHandler;
import cn.com.wind.starter.log.intercepter.ControllerAdviceMissCondition;
import cn.com.wind.starter.log.prop.GlobalDefaultProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Conditional;

@AutoConfiguration
@EnableConfigurationProperties(GlobalDefaultProperties.class)
@AutoConfigureBefore(MethodLogAutoConfiguration.class)
@Conditional(ControllerAdviceMissCondition.class)
public class GlobalDefaultConfiguration {

    private static final Logger log = LoggerFactory.getLogger(GlobalDefaultConfiguration.class);

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(
            prefix = "log.exception.defaultExceptionHandler",
            name = {"enabled"},
            havingValue = "true",
            matchIfMissing = false
    )

    public GlobalDefaultExceptionHandler globalDefaultExceptionHandler(GlobalDefaultProperties properties) {
        log.info("log.exception.defaultExceptionHandler.enable= true, 注入全局异常处理器GlobalDefaultExceptionHandler");
        return new GlobalDefaultExceptionHandler(properties);
    }

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(
            prefix = "log.exception.responseDataAdvice",
            name = {"enabled"},
            havingValue = "true",
            matchIfMissing = false
    )
    public CommonResponseDataAdvice commonResponseDataAdvice(GlobalDefaultProperties globalDefaultProperties) {
        log.info("log.exception.responseDataAdvice.enable= true, 注入响应处理器CommonResponseDataAdvice");
        return new CommonResponseDataAdvice(globalDefaultProperties);
    }

}
package cn.com.wind.starter.log.configuration;

import cn.com.wind.starter.log.filter.HttpRequestMDCFilter;
import cn.com.wind.starter.log.handler.ControllerLogAspect;
import cn.com.wind.starter.log.prop.EagleSenderProperties;
import cn.com.wind.starter.log.prop.UrlFilterProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;

@AutoConfiguration
@ConditionalOnMissingClass("org.springframework.cloud.gateway.filter.GlobalFilter")
@EnableConfigurationProperties({EagleSenderProperties.class,UrlFilterProperties.class})
public class MethodLogAutoConfiguration {

    private static final Logger log = LoggerFactory.getLogger(MethodLogAutoConfiguration.class);

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(
            prefix = "log.methodLogAspect",
            name = {"enabled"},
            havingValue = "true",
            matchIfMissing = false
    )
    public ControllerLogAspect methodLogAspect(UrlFilterProperties urlFilterProperties,EagleSenderProperties eagleSenderProperties){
        log.info("log.methodLogAspect.enable= true, 注入日志切面ControllerLogAspect");
        return new ControllerLogAspect(urlFilterProperties,eagleSenderProperties);
    }

    @Bean
    @ConditionalOnProperty(
            prefix = "log.httpRequestMDCFilter",
            name = {"enabled"},
            havingValue = "true",
            matchIfMissing = false
    )
    @ConditionalOnMissingBean
    public HttpRequestMDCFilter httpRequestMDCFilter(){
        log.info("log.httpRequestMDCFilter.enable= true, 注入过滤器HttpRequestMDCFilter");
        return new HttpRequestMDCFilter();
    }


}
package cn.com.wind.starter.log.constant;

public class MDCConstants {
 
   public static final  String traceId = "traceId";

   public static final  String userId = "userId";

   public static final  String requestChannel = "requestChannel";
}
package cn.com.wind.starter.log.enums;



/**
 * 业务状态
 */

public enum BusinessStatus{
    /**
     * 成功
     */
    SUCCESS,

    /**
     * 失败
     */
    FAIL,



}
package cn.com.wind.starter.log.enums;

public enum CommonErrorCode {

    /**
     * 404 Web 服务器找不到您所请求的文件或脚本。请检查URL 以确保路径正确。
     */
    NOT_FOUND("CLOUD-404",
            "哎呀，无法找到这个资源啦(Not Found)"),

    /**
     * 405 对于请求所标识的资源，不允许使用请求行中所指定的方法。请确保为所请求的资源设置了正确的 MIME 类型。
     */
    METHOD_NOT_ALLOWED("CLOUD-405",
            "请换个姿势操作试试(Method Not Allowed)"),

    /**
     * 415 Unsupported Media Type
     */
    UNSUPPORTED_MEDIA_TYPE("CLOUD-415",
            "呀，不支持该媒体类型(Unsupported Media Type)"),

    /**
     * 系统异常 500 服务器的内部错误
     */
    EXCEPTION("CLOUD-500", "服务器开小差，请稍后再试"),

    /**
     * 系统限流
     */
    TRAFFIC_LIMITING("CLOUD-429", "哎呀，网络拥挤请稍后再试试"),

    /**
     * 服务调用异常
     */
    API_GATEWAY_ERROR("API-9999", "网络繁忙，请稍后再试"),

    /**
     * 参数错误
     */
    PARAM_ERROR("CLOUD-100", "参数错误"),

    /**
     * 业务异常
     */
    BUSINESS_ERROR("CLOUD-400", "业务异常"),

    /**
     * 非法请求
     */
    ILLEGAL_REQUEST("CLOUD-ILLEGAL_REQUEST", "非法请求"),

    /**
     * rpc调用异常
     */
    RPC_ERROR("RPC-510", "呀，网络出问题啦！");

    private String code;

    private String message;

    public String getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    CommonErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }
}

package cn.com.wind.starter.log.enums;

public interface ExceptionEnum {

    String getCode();

    String getMsg();


}
package cn.com.wind.starter.log.enums;



/**
 * 操作用户
 */

public enum OperatorType{
    /**
     * 其它
     */
    OTHER,

    /**
     * 后台用户
     */
    MANAGE,

    /**
     * 手机端用户
     */
    MOBILE


}


package cn.com.wind.starter.log.filter;

import cn.com.wind.starter.log.constant.MDCConstants;
import cn.com.wind.starter.log.utils.StringUtils;
import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.io.IOException;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.util.Enumeration;
import java.util.UUID;


public class HttpRequestMDCFilter implements Filter {

    private static final Logger log = LoggerFactory.getLogger(HttpRequestMDCFilter.class);



    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    private String getLocalIp() {
        try {
            Enumeration<NetworkInterface> netInterfaces = NetworkInterface.getNetworkInterfaces();
            while (netInterfaces.hasMoreElements()) {
                NetworkInterface netInterface = netInterfaces.nextElement();
                Enumeration<InetAddress> addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    InetAddress address = addresses.nextElement();
                    if (address.isSiteLocalAddress() && !address.isLoopbackAddress()) {
                        return address.getHostAddress();
                    }
                }
            }
        }catch (Exception e) {
            log.error("getLocalIp error",e);
            return null;
        }
        return null;
    }
 
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        HttpServletRequest hsr = (HttpServletRequest) request;
        try {
            mdc(hsr);
            chain.doFilter(request, response);
        } finally {
            // 保证每个请求结束后清理，防止线程池复用造成串日志
            MDC.clear();
        }
    }
 
    private void mdc(HttpServletRequest hsr) {
        String traceId = hsr.getHeader(MDCConstants.traceId);
        if (StringUtils.isEmpty(traceId)){
            traceId = UUID.randomUUID().toString().replace("-","");
        }
        MDC.put(MDCConstants.traceId, traceId);
        MDC.put(MDCConstants.userId, hsr.getHeader(MDCConstants.userId));
        MDC.put(MDCConstants.requestChannel, hsr.getHeader(MDCConstants.requestChannel));

    }
 
    @Override
    public void destroy() {

    }
}

package cn.com.wind.starter.log.handler;

import cn.com.wind.starter.log.annotation.IgnoreResponseAdvice;
import cn.com.wind.starter.log.prop.GlobalDefaultProperties;
import cn.com.wind.starter.log.model.Result;
import com.alibaba.fastjson.JSON;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.lang.Nullable;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

import java.util.List;
import java.util.Objects;

/**
 *  * {@link IgnoreResponseAdvice} 处理解析 {@link ResponseBodyAdvice} 统一返回包装器
 */
@RestControllerAdvice
public class CommonResponseDataAdvice implements ResponseBodyAdvice<Object> {

    private final GlobalDefaultProperties globalDefaultProperties;

    public CommonResponseDataAdvice(GlobalDefaultProperties globalDefaultProperties) {
        this.globalDefaultProperties = globalDefaultProperties;
    }


    @Override
    @SuppressWarnings("all")
    public boolean supports(MethodParameter methodParameter,
                            Class<? extends HttpMessageConverter<?>> aClass) {
        List<String> adviceFilterPackage = globalDefaultProperties.getAdviceFilterPackage();
        //过滤 swagger
        adviceFilterPackage.add("springfox.documentation");
        //过滤 spring 官方包
        adviceFilterPackage.add("org.springframework");
        return filter(methodParameter);
    }

    @Nullable
    @Override
    @SuppressWarnings("all")
    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType,
                                  Class<? extends HttpMessageConverter<?>> aClass, ServerHttpRequest serverHttpRequest,
                                  ServerHttpResponse serverHttpResponse) {

        // 返回值为 Object 类型  并且返回为空是  AbstractMessageConverterMethodProcessor#writeWithMessageConverters 方法
        // 无法触发调用本类的 beforeBodyWrite 处理，开发在 Controller 尽量避免直接使用 Object 类型返回。

        // o is null -> return response
        if (o == null) {
            // 当 o 返回类型为 string 并且为null会出现 java.lang.ClassCastException: Result cannot be cast to java.lang.String
            if ("java.lang.String".equals(methodParameter.getParameterType().getName())) {
                return JSON.toJSONString(Result.ofSuccess());
            }
            return Result.ofSuccess();
        }
        // o is instanceof ConmmonResponse -> return o
        if (o instanceof Result) {
            return  o;
        }
        // string 特殊处理 java.lang.ClassCastException: Result cannot be cast to java.lang.String
        if (o instanceof String) {
            return JSON.toJSONString(Result.ofSuccess(o));
        }
        return Result.ofSuccess(o);
    }

    private Boolean filter(MethodParameter methodParameter) {
        Class<?> declaringClass = methodParameter.getDeclaringClass();
        // 检查过滤包路径
        long count = globalDefaultProperties.getAdviceFilterPackage().stream()
                .filter(l -> declaringClass.getName().contains(l)).count();
        if (count > 0) {
            return false;
        }
        // 检查<类>过滤列表
        if (globalDefaultProperties.getAdviceFilterClass().contains(declaringClass.getName())) {
            return false;
        }
        // 检查注解是否存在
        if (methodParameter.getDeclaringClass().isAnnotationPresent(IgnoreResponseAdvice.class)) {
            return false;
        }
        if (Objects.requireNonNull(methodParameter.getMethod()).isAnnotationPresent(IgnoreResponseAdvice.class)) {
            return false;
        }
        return true;
    }

}


package cn.com.wind.starter.log.handler;


import cn.com.wind.starter.log.annotation.Log;
import cn.com.wind.starter.log.enums.BusinessStatus;
import cn.com.wind.starter.log.model.SysOperLogDto;
import cn.com.wind.starter.log.prop.EagleSenderProperties;
import cn.com.wind.starter.log.prop.UrlFilterProperties;
import cn.com.wind.starter.log.utils.*;
import com.alibaba.fastjson.JSON;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.commons.lang3.StringEscapeUtils;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.Environment;
import org.springframework.http.MediaType;
import org.springframework.validation.BindingResult;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.multipart.MultipartFile;

import java.lang.reflect.Method;
import java.util.*;

/**
 * 操作日志记录处理
 */
@Aspect
@Order(-2147483647)
public class ControllerLogAspect {


    @Autowired
    private Environment environment;


    private static final Logger log = LoggerFactory.getLogger(ControllerLogAspect.class);

    private final UrlFilterProperties urlFilterProperties;
    private final EagleSenderProperties eagleSenderProperties;

    public ControllerLogAspect(UrlFilterProperties urlFilterProperties, EagleSenderProperties eagleSenderProperties) {
        this.urlFilterProperties = urlFilterProperties;
        this.eagleSenderProperties = eagleSenderProperties;
    }


    // 配置织入点
    @Pointcut("@annotation(org.springframework.web.bind.annotation.PostMapping) || @annotation(org.springframework.web.bind.annotation.GetMapping) || @annotation(org.springframework.web.bind.annotation.RequestMapping) ")
    public void logPointCut() {
    }


    /**
     * @description 使用环绕通知
     * <p>
     * <p>
     * 环绕通知可以将你所编写的逻辑将被通知的目标方法完全包装起来。
     * 我们可以使用一个环绕通知来代替之前多个不同的前置通知和后置通知。
     * 如下所示，前置通知和后置通知位于同一个方法中，不像之前那样分散在不同的通知方法里面。
     */
    @Around("logPointCut()")
    public Object doAroundGame(ProceedingJoinPoint joinPoint) throws Throwable {
        if (RequestContextHolder.getRequestAttributes() == null){
                return joinPoint.proceed();
        }
        long start = System.currentTimeMillis();
        SysOperLogDto operLog = new SysOperLogDto();
        Boolean globalSwitch = eagleSenderProperties.getGlobalSwitch();
        Boolean isSend = eagleSenderProperties.getSend();
        try {

            if (Objects.nonNull(environment)) {
                operLog.setModel(environment.getProperty("spring.application.name"));
            }

            // 构建请求前的操作信息
            buildPreOperLog(joinPoint, operLog);
            // 获得注解
            Log controllerLog = getAnnotationLog(joinPoint);
            if (Objects.nonNull(controllerLog)) {
                // 设置操作人类别
                operLog.setOperatorType(controllerLog.operatorType().name());
            } else {
                String param = "";
                // 根据url选择过滤请求参数
                if (urlFilterProperties.getBigDataUrls().contains(operLog.getOperUrl()) || urlFilterProperties.getGlobalSwitch()) {
                    try {
                        param = buildRequestParamHideBase64(joinPoint);
                    } catch (Throwable e) {
                        // 便于检查暂用info级别
                        log.error("buildRequestParam获取参数异常", e);
                        param = buildRequestParam(joinPoint);
                    }
                } else {
                    param = buildRequestParam(joinPoint);

                }
                operLog.setOperParam(param);
            }
            // 执行
            Object resp = joinPoint.proceed();
            long end = System.currentTimeMillis();
            long spend = end - start;
            operLog.setContinueTime(String.valueOf(spend));
            if (urlFilterProperties.getBigDataUrls().contains(operLog.getOperUrl()) || urlFilterProperties.getGlobalSwitch()) {
                try {
                    Object o = HideBigDataUtils.hideObject(resp);
                    operLog.setJsonResult(StringEscapeUtils.unescapeJson(FastJsonUtil.toJson(o)));
                } catch (Throwable e) {
                    // 便于检查暂用info级别
                    log.error("设置响应参数异常", e);
                    operLog.setJsonResult(StringEscapeUtils.unescapeJson(FastJsonUtil.toJson(resp)));
                }
            } else {
                operLog.setJsonResult(StringEscapeUtils.unescapeJson(FastJsonUtil.toJson(resp)));

            }

            operLog.setStatus(BusinessStatus.SUCCESS.name());

            log.info("api:{}->{}|time:{}ms|method:{}|ip:{}|--->req:{}|<---resp:{}",
                    operLog.getOperUrl(),
                    operLog.getStatus(),
                    operLog.getContinueTime(),
                    operLog.getMethod(),
                    operLog.getOperIp(),
                    operLog.getOperParam(),
                    operLog.getJsonResult());
            try {
                if (globalSwitch && isSend) {
                    EagleSender.sendInfo(StringUtils.format("api:{}->{}|time:{}ms|method:{}|ip:{}|--->req:{}|<---resp:{}",
                            operLog.getOperUrl(),
                            operLog.getStatus(),
                            operLog.getContinueTime(),
                            operLog.getMethod(),
                            operLog.getOperIp(),
                            operLog.getOperParam(),
                            operLog.getJsonResult()));
                }
            } catch (Exception exception) {
                log.error("发送消息至eagle失败");
            }

            return resp;

        } catch (Throwable e) {
            long end = System.currentTimeMillis();
            long spend = end - start;
            operLog.setContinueTime(String.valueOf(spend));
            operLog.setStatus(BusinessStatus.FAIL.name());
            operLog.setErrorMsg(StringUtils.substring(e.getMessage(), 0, 2000));
            // 记录本地异常日志

            log.error("api:{}->{}|time:{}ms|method:{}|ip:{}|--->req:{}|ex:{}|msg:{}",
                    operLog.getOperUrl(),
                    operLog.getStatus(),
                    operLog.getContinueTime(),
                    operLog.getMethod(),
                    operLog.getOperIp(),
                    operLog.getOperParam(),
                    e.getClass().getName(),
                    e.getMessage(),
                    e);

            try {
                if (globalSwitch && isSend) {
                    EagleSender.sendError(StringUtils.format("api:{}->{}|time:{}ms|method:{}|ip:{}|--->req:{}|ex:{}|msg:{}",
                            operLog.getOperUrl(),
                            operLog.getStatus(),
                            operLog.getContinueTime(),
                            operLog.getMethod(),
                            operLog.getOperIp(),
                            operLog.getOperParam(),
                            e.getClass().getName(),
                            ErrorLogUtils.getErrorMsg(e,-1)
                    ));
                }
            } catch (Exception exception) {
                log.error("发送消息至eagle失败");
            }
            // 抛出业务异常e
            throw e;
        }


    }

    private String buildRequestParamHideBase64(ProceedingJoinPoint joinPoint) {

        HttpServletRequest request = ServletUtil.getRequest();
        if (StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE)) {
            StringBuilder params = new StringBuilder();
            Object[] paramsArray = joinPoint.getArgs();
            if (paramsArray != null && paramsArray.length > 0) {
                for (Object o : paramsArray) {
                    // 如果是需要过滤的对象(如文件)，则返回true；否则返回false。
                    if (!isFilterObject(o)) {
                        Object o1 = HideBigDataUtils.hideObject(o);
                        Object jsonObj = JSON.toJSON(o1);
                        params.append(StringEscapeUtils.unescapeJson(String.valueOf(jsonObj)));
                        params.append(" ");
                    }
                }
            }
            return params.toString().trim();
        }
        Map<String, String> map = new HashMap<>();
        Enumeration<String> paramNames = request.getParameterNames();
        while (paramNames.hasMoreElements()) {
            String paramName = paramNames.nextElement();
            String[] paramValues = request.getParameterValues(paramName);
            if (paramValues.length == 1) {
                String paramValue = paramValues[0];
                if (paramValue.length() != 0) {
                    Object o1 = HideBigDataUtils.hideObject(paramValue);
                    map.put(paramName, StringEscapeUtils.unescapeJson(String.valueOf(o1)));
                }
            }
        }
        return String.valueOf(map);
    }


    /**
     * 构建操作之前的log信息
     *
     * @param joinPoint
     * @param operLog
     */
    private void buildPreOperLog(ProceedingJoinPoint joinPoint, SysOperLogDto operLog) {

        //请求的地址
        operLog.setOperIp(getIpAddress());
        String requestUri = ServletUtil.getRequest().getRequestURI();
        operLog.setOperUrl(requestUri);

        // 设置方法名称
        String className = joinPoint.getTarget().getClass().getName();
        String methodName = joinPoint.getSignature().getName();
        // 设置请求方式
        operLog.setRequestMethod(ServletUtil.getRequest().getMethod());
        operLog.setMethod(className + "." + methodName + "()");
        operLog.setOperTime(new Date());
    }


    /**
     * 是否存在注解，如果存在就获取
     */
    private Log getAnnotationLog(JoinPoint joinPoint) {
        Signature signature = joinPoint.getSignature();
        MethodSignature methodSignature = (MethodSignature) signature;
        Method method = methodSignature.getMethod();

        if (method != null) {
            return method.getAnnotation(Log.class);
        }
        return null;
    }


    /**
     * 判断是否需要过滤的对象。
     *
     * @param o 对象信息。
     * @return 如果是需要过滤的对象，则返回true；否则返回false。
     */
    public static boolean isFilterObject(final Object o) {
        return o instanceof MultipartFile || o instanceof HttpServletRequest || o instanceof HttpServletResponse
                || o instanceof BindingResult;
    }


    /**
     * 构建参数信息
     *
     * @return
     */
    public static String buildRequestParam(ProceedingJoinPoint point) {
        try {
            HttpServletRequest request = ServletUtil.getRequest();
            if (StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE)) {
                StringBuilder params = new StringBuilder();
                Object[] paramsArray = point.getArgs();
                if (paramsArray != null && paramsArray.length > 0) {
                    for (Object o : paramsArray) {
                        // 如果是需要过滤的对象(如文件)，则返回true；否则返回false。
                        if (!isFilterObject(o)) {
                            Object jsonObj = JSON.toJSON(o);
                            params.append(StringEscapeUtils.unescapeJson(String.valueOf(jsonObj)));
                            params.append(" ");
                        }
                    }
                }
                return params.toString().trim();
            }
            Map<String, String> map = new HashMap<>();
            Enumeration<String> paramNames = request.getParameterNames();
            while (paramNames.hasMoreElements()) {
                String paramName = paramNames.nextElement();
                String[] paramValues = request.getParameterValues(paramName);
                if (paramValues.length == 1) {
                    String paramValue = paramValues[0];
                    if (paramValue.length() != 0) {
                        map.put(paramName, StringEscapeUtils.unescapeJson(paramValue));
                    }
                }
            }
            return String.valueOf(map);
        } catch (Exception e) {
            log.error("buildRequestParam获取参数异常", e);
            return "";
        }
    }


    /**
     * 获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址,
     * <p>
     * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？
     * 答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。
     *
     * @return
     */
    public static String getIpAddress() {
        HttpServletRequest request = ServletUtil.getRequest();
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        String defaultIp = "0:0:0:0:0:0:0:1";
        final String localhostIp = "127.0.0.1";
        return ip.equals(defaultIp) ? localhostIp : ip;
    }
}
package cn.com.wind.starter.log.handler;

import cn.com.wind.starter.log.annotation.IgnoreResponseAdvice;
import cn.com.wind.starter.log.enums.CommonErrorCode;
import cn.com.wind.starter.log.model.BusinessException;
import cn.com.wind.starter.log.model.Result;
import cn.com.wind.starter.log.prop.GlobalDefaultProperties;
import cn.com.wind.starter.log.service.InvokeExceptionService;
import cn.com.wind.starter.log.utils.ErrorLogUtils;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.BindException;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.HttpMediaTypeNotSupportedException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.NoHandlerFoundException;

import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Objects;
import java.util.Set;

@RestControllerAdvice
public class GlobalDefaultExceptionHandler {

    private final static Logger log = LoggerFactory.getLogger(GlobalDefaultExceptionHandler.class);

    private final GlobalDefaultProperties properties ;


    @Autowired(required = false)
    private InvokeExceptionService invokeExceptionService;

    public GlobalDefaultExceptionHandler(GlobalDefaultProperties properties) {
        this.properties = properties;
    }


    /**
     * NoHandlerFoundException 404 异常处理
     */
    @ExceptionHandler(value = NoHandlerFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public Result<String> handlerNoHandlerFoundException(NoHandlerFoundException e) throws Throwable {
        errorDispose(e);
        outPutErrorWarn(NoHandlerFoundException.class, CommonErrorCode.NOT_FOUND, e);
        return Result.ofFail(CommonErrorCode.NOT_FOUND);
    }

    /**
     * HttpRequestMethodNotSupportedException 405 异常处理
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public Result<String> handlerHttpRequestMethodNotSupportedException(
            HttpRequestMethodNotSupportedException e) throws Throwable {
        errorDispose(e);
        outPutErrorWarn(HttpRequestMethodNotSupportedException.class,
                CommonErrorCode.METHOD_NOT_ALLOWED, e);
        return Result.ofFail(CommonErrorCode.METHOD_NOT_ALLOWED);
    }

    /**
     * HttpMediaTypeNotSupportedException 415 异常处理
     */
    @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
    public Result<String> handlerHttpMediaTypeNotSupportedException(
            HttpMediaTypeNotSupportedException e) throws Throwable {
        errorDispose(e);
        outPutErrorWarn(HttpMediaTypeNotSupportedException.class,
                CommonErrorCode.UNSUPPORTED_MEDIA_TYPE, e);
        return Result.ofFail(CommonErrorCode.UNSUPPORTED_MEDIA_TYPE);
    }

    /**
     * Exception 类捕获 500 异常处理
     */
    @ExceptionHandler(value = Exception.class)
    public Result<?> handlerException(Exception e) throws Throwable {
        errorDispose(e);
        return ifDepthExceptionType(e);
    }

    /**
     * 二次深度检查错误类型
     */
    private Result<?> ifDepthExceptionType(Exception exception) throws Throwable {
        Throwable cause = exception.getCause();
//        if (cause instanceof ClientException) {
//            return handlerClientException((ClientException) cause);
//        }
//        if (cause instanceof FeignException) {
//            return handlerFeignException((FeignException) cause);
//        }
        if (Objects.nonNull(invokeExceptionService)){
            Integer handler = invokeExceptionService.handler();
            if (Objects.equals(handler,0)){
                return  invokeExceptionService.doSomeThingWithReturn(exception);
            }else {
                invokeExceptionService.doSomeThing(exception);
            }
        }
        outPutError(Exception.class, CommonErrorCode.EXCEPTION, exception);
        return Result.ofFail(CommonErrorCode.EXCEPTION);

    }

//    /**
//     * FeignException 类捕获
//     */
//    @ExceptionHandler(value = FeignException.class)
//    public Result handlerFeignException(FeignException e) throws Throwable {
//        errorDispose(e);
//        outPutError(FeignException.class, CommonErrorCode.RPC_ERROR, e);
//        return Result.ofFail(CommonErrorCode.RPC_ERROR);
//    }

//    /**
//     * ClientException 类捕获
//     */
//    @ExceptionHandler(value = ClientException.class)
//    public Result handlerClientException(ClientException e) throws Throwable {
//        errorDispose(e);
//        outPutError(ClientException.class, CommonErrorCode.RPC_ERROR, e);
//        return Result.ofFail(CommonErrorCode.RPC_ERROR);
//    }

    /**
     * BusinessException 类捕获
     */
    @ExceptionHandler(value = BusinessException.class)
    public Result<String> handlerBusinessException(BusinessException e) throws Throwable {
        errorDispose(e);
        outPutError(BusinessException.class, CommonErrorCode.BUSINESS_ERROR, e);
        return Result.ofFail(e.getCode(), e.getMessage());
    }

    /**
     * HttpMessageNotReadableException 参数错误异常
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public Result<String> handleHttpMessageNotReadableException(HttpMessageNotReadableException e) throws Throwable {
        errorDispose(e);
        outPutError(HttpMessageNotReadableException.class, CommonErrorCode.PARAM_ERROR, e);
        String msg = String.format("%s : 错误详情( %s )", CommonErrorCode.PARAM_ERROR.getMessage(),
                e.getRootCause().getMessage());
        return Result.ofFail(CommonErrorCode.PARAM_ERROR.getCode(), msg);
    }

    /**
     * ConstraintViolationException 参数错误异常
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public Result<String> handleConstraintViolationException(ConstraintViolationException e) throws Throwable {
        errorDispose(e);
        String smg = "";
        Set<ConstraintViolation<?>> constraintViolations = e.getConstraintViolations();
        if (log.isDebugEnabled()) {
            for (ConstraintViolation<?> error : constraintViolations) {
                log.error("{} -> {}", error.getPropertyPath(), error.getMessageTemplate());
                smg = error.getMessageTemplate();
            }
        }

        if (constraintViolations.isEmpty()) {
            log.error("validExceptionHandler error fieldErrors is empty");
            Result.ofFail(CommonErrorCode.BUSINESS_ERROR.getCode(), "");
        }

        return Result.ofFail(CommonErrorCode.PARAM_ERROR.getCode(), smg);
    }

    /**
     * MethodArgumentNotValidException 参数错误异常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<String> handleMethodArgumentNotValidException(MethodArgumentNotValidException e) throws Throwable {
        errorDispose(e);
        BindingResult bindingResult = e.getBindingResult();
        return getBindResultDTO(bindingResult);
    }

    /**
     * BindException 参数错误异常
     */
    @ExceptionHandler(BindException.class)
    public Result<String> handleBindException(BindException e) throws Throwable {
        errorDispose(e);
        outPutError(BindException.class, CommonErrorCode.PARAM_ERROR, e);
        BindingResult bindingResult = e.getBindingResult();
        return getBindResultDTO(bindingResult);
    }

    private Result<String> getBindResultDTO(BindingResult bindingResult) {
        List<FieldError> fieldErrors = bindingResult.getFieldErrors();
        if (log.isDebugEnabled()) {
            for (FieldError error : fieldErrors) {
                log.error("{} -> {}", error.getDefaultMessage(), error.getDefaultMessage());
            }
        }

        if (fieldErrors.isEmpty()) {
            log.error("validExceptionHandler error fieldErrors is empty");
            Result.ofFail(CommonErrorCode.BUSINESS_ERROR.getCode(), "");
        }

        return Result
                .ofFail(CommonErrorCode.PARAM_ERROR.getCode(), fieldErrors.get(0).getDefaultMessage());
    }

    /**
     * 校验是否进行异常处理
     *
     * @param e   异常
     * @param <T> extends Throwable
     * @throws Throwable 异常
     */
    private <T extends Throwable> void errorDispose(T e) throws Throwable {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        HandlerMethod handlerMethod = (HandlerMethod) request.getAttribute("org.springframework.web.servlet.HandlerMapping.bestMatchingHandler");

        // 未进入到Controller
        if (Objects.isNull(handlerMethod)){
            return;
        }
        // 获取异常 Controller
        Class<?> beanType = handlerMethod.getBeanType();
        // 获取异常方法
        Method method = handlerMethod.getMethod();

        // 判断方法是否存在 IgnoreResponseAdvice 注解
        IgnoreResponseAdvice methodAnnotation = method.getAnnotation(IgnoreResponseAdvice.class);
        if (methodAnnotation != null) {
            // 是否使用异常处理
            if (!methodAnnotation.errorDispose()) {
                throw e;
            } else {
                return;
            }
        }
        // 判类是否存在 IgnoreResponseAdvice 注解
        IgnoreResponseAdvice classAnnotation = beanType.getAnnotation(IgnoreResponseAdvice.class);
        if (classAnnotation != null) {
            if (!classAnnotation.errorDispose()) {
                throw e;
            }
        }
    }


    /**
     * 打印错误日志
     * @param errorType
     * @param secondaryErrorType
     * @param throwable
     */
    public void outPutError(Class errorType, Enum secondaryErrorType, Throwable throwable) {
        // 如果为自定义异常 仅打印异常所在stackTraceElement 节省log
        if (throwable instanceof BusinessException) {
            StackTraceElement stackTraceElement = throwable.getStackTrace()[0];
            log.error("[{}] {}: {} {}", errorType.getSimpleName(), secondaryErrorType, throwable.getMessage(), stackTraceElement.toString());
            return;
        }
        String throwableString = ErrorLogUtils.getErrorMsg(throwable, properties.getErrorMsgShowMaxCount());
        log.error("[{}] {}: {} {}", errorType.getSimpleName(), secondaryErrorType, throwable.getMessage(), throwableString);
    }


    /**
     * 打印警告日志
     * @param errorType
     * @param secondaryErrorType
     * @param throwable
     */
    public void outPutErrorWarn(Class errorType, Enum secondaryErrorType, Throwable throwable) {
        String throwableString = ErrorLogUtils.getErrorMsg(throwable, properties.getErrorMsgShowMaxCount());
        log.warn("[{}] {}: {} {}", errorType.getSimpleName(), secondaryErrorType, throwable.getMessage(),throwableString);
    }




}


package cn.com.wind.starter.log.handler;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.pattern.MessageConverter;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.IThrowableProxy;
import ch.qos.logback.classic.spi.StackTraceElementProxy;
import cn.hutool.extra.spring.SpringUtil;
import org.apache.commons.lang3.StringUtils;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class LogbackMessConverter extends MessageConverter {

    private static boolean eagleInit = false;


    public LogbackMessConverter() {
    }

    @Override
    public String convert(ILoggingEvent event) {
        try {
            String loggerName = event.getLoggerName();
            String message = event.getMessage();
            String isSend = SpringUtil.getProperty("log.eagle.send");
            String eagleLevel = SpringUtil.getProperty("log.eagle.level");
            Level level = event.getLevel();
            String[] levelList = {"error"};
            if (StringUtils.isNotEmpty(eagleLevel)) {
                levelList = eagleLevel.split(",");
            }
            List<String> levels = Arrays.stream(levelList).collect(Collectors.toList());
            boolean info = levels.contains("info");
            boolean error = levels.contains("error");
            boolean warn = levels.contains("warn");

            if (!eagleInit) {
                if (!loggerName.contains("EagleService") && !message.contains("eagles client init success")) {
                    return super.convert(event);
                } else {
                    eagleInit = true;
                }
            }


            if (StringUtils.equalsAnyIgnoreCase(isSend, "true")) {
                return super.convert(event);
            }

            handleThrowable(event, info, error, warn);
        } catch (Exception exception) {
            return super.convert(event);
        }


        return super.convert(event);
    }


    /**
     * 处理异常
     *
     * @param info
     * @param error
     * @param warn
     */
    private void handleThrowable(ILoggingEvent iLoggingEvent, boolean info, boolean error, boolean warn) {
        String loggerName = iLoggingEvent.getLoggerName();
        Level level = iLoggingEvent.getLevel();
        String message = iLoggingEvent.getMessage();
        if (loggerName.contains("cn.com.wind.eaglesapi.services.EagleService")) {
             return;
        }
        //有异常

        IThrowableProxy throwableProxy = iLoggingEvent.getThrowableProxy();

        if (Objects.nonNull(throwableProxy)) {
            StackTraceElementProxy[] stackTraceElementProxyArray = throwableProxy.getStackTraceElementProxyArray();
            if (Objects.equals(Level.INFO, level) && info) {
                EagleSender.sendInfo(Arrays.toString(stackTraceElementProxyArray));
            } else if (Objects.equals(Level.WARN, level) && warn) {
                EagleSender.sendWarn(Arrays.toString(stackTraceElementProxyArray));
            } else if (Objects.equals(Level.ERROR, level) && error) {
                EagleSender.sendError(Arrays.toString(stackTraceElementProxyArray));
            }
        } else {
            if (Objects.equals(Level.INFO, level) && info) {
                EagleSender.sendInfo(message);
            } else if (Objects.equals(Level.WARN, level) && warn) {
                EagleSender.sendWarn(message);
            } else if (Objects.equals(Level.ERROR, level) && error) {
                EagleSender.sendError(message);
            }
        }
    }
}
package cn.com.wind.starter.log.handler;

import cn.com.wind.starter.log.utils.ErrorLogUtils;
import cn.hutool.extra.spring.SpringUtil;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.appender.rewrite.RewritePolicy;
import org.apache.logging.log4j.core.config.Configuration;
import org.apache.logging.log4j.core.config.Node;
import org.apache.logging.log4j.core.config.plugins.Plugin;
import org.apache.logging.log4j.core.config.plugins.PluginConfiguration;
import org.apache.logging.log4j.core.config.plugins.PluginFactory;
import org.apache.logging.log4j.core.config.plugins.PluginNode;
import org.apache.logging.log4j.core.impl.Log4jLogEvent;
import org.apache.logging.log4j.core.impl.MutableLogEvent;
import org.apache.logging.log4j.message.Message;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Plugin(name = "SensitiveRewritePolicy", category = Node.CATEGORY, elementType = "rewritePolicy", printObject = true)
public class SensitiveRewritePolicy implements RewritePolicy {


    private static boolean eagleInit = false;


    public SensitiveRewritePolicy() {
    }

    @Override
    public LogEvent rewrite(LogEvent source) {
        String eagleLevel = SpringUtil.getProperty("log.eagle.level");
        String isSend = SpringUtil.getProperty("log.eagle.send");
        String loggerName = source.getLoggerName();
        String message = source.getMessage().getFormattedMessage();
        try {
            if (!eagleInit) {
                if (!loggerName.contains("EagleService") && !message.contains("eagles client init success")) {
                    return source;
                } else {
                    eagleInit = true;
                }
            }
            if (StringUtils.isEmpty(isSend) || StringUtils.equalsAnyIgnoreCase(isSend, "true")) {
                return source;
            }
            handlerThrowable(source, eagleLevel);
            // 直接返回原始的。
            return source;
        } catch (Exception e) {
            return source;
        }
    }

    private Message getMessage(LogEvent source) {
        if (source instanceof Log4jLogEvent) {
            Log4jLogEvent log4jLogEvent = (Log4jLogEvent) source;
            return log4jLogEvent.getMessage();
        } else if (source instanceof MutableLogEvent) {
            MutableLogEvent log4jLogEvent = (MutableLogEvent) source;
            return log4jLogEvent.getMessage();
        }

        return source.getMessage();
    }

    // 指定对应的 factory

    /**
     * @param pluginConfig 配置
     * @param pluginNode   节点
     * @return 结果
     */
    @PluginFactory
    public static SensitiveRewritePolicy createPolicy(@PluginConfiguration Configuration pluginConfig,
                                                      @PluginNode Node pluginNode
    ) {
        //TODO 根据用户指定的参数初始化
        return new SensitiveRewritePolicy();
    }


    public void handlerThrowable(LogEvent iLoggingEvent,String eagleLevel) {
        Level level = iLoggingEvent.getLevel();
        String loggerName = iLoggingEvent.getLoggerName();
        Throwable throwable = iLoggingEvent.getThrown();
        String[] levelList = {"error"};
        if (StringUtils.isNotEmpty(eagleLevel)) {
            levelList = eagleLevel.split(",");
        }
        List<String> levels = Arrays.stream(levelList).collect(Collectors.toList());
        boolean info = levels.contains("info");
        boolean error = levels.contains("error");
        boolean warn = levels.contains("warn");
        String message = iLoggingEvent.getMessage().getFormattedMessage();
        if (loggerName.contains("cn.com.wind.eaglesapi.services.EagleService")) {
            return;
        }
        //有异常
        if (Objects.nonNull(throwable)) {
            if (Objects.equals(Level.INFO, level) && info) {
                EagleSender.sendInfo(ErrorLogUtils.getErrorMsg(throwable,-1));
            } else if (Objects.equals(Level.WARN, level) && warn) {
                EagleSender.sendWarn(ErrorLogUtils.getErrorMsg(throwable,-1));
            } else if (Objects.equals(Level.ERROR, level) && error) {
                EagleSender.sendError( ErrorLogUtils.getErrorMsg(throwable,-1));
            }
        } else {
            if (Objects.equals(Level.INFO, level) && info) {
                EagleSender.sendInfo(message);
            } else if (Objects.equals(Level.WARN, level) && warn) {
                EagleSender.sendWarn(message);
            } else if (Objects.equals(Level.ERROR, level) && error) {
                EagleSender.sendError(message);
            }
        }
    }
}


package cn.com.wind.starter.log.intercepter;

import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.annotation.Condition;
import org.springframework.context.annotation.ConditionContext;
import org.springframework.core.type.AnnotatedTypeMetadata;
import org.springframework.web.bind.annotation.ControllerAdvice;

import java.util.Map;

public class ControllerAdviceMissCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
        Map<String, Object> beansWithAnnotation = beanFactory.getBeansWithAnnotation(ControllerAdvice.class);
        return beansWithAnnotation.isEmpty();
    }
}
package cn.com.wind.starter.log.model;

import cn.com.wind.starter.log.enums.CommonErrorCode;
import cn.com.wind.starter.log.enums.ExceptionEnum;
import org.springframework.http.HttpStatus;

public class BusinessException extends RuntimeException {

    /**
     * 所属模块
     */
    private String module;

    /**
     * 错误码
     */
    private String code;

    /**
     * 抛出的异常
     */
    private Throwable throwable;

    /**
     * 错误码对应的参数
     */
    private Object[] args;

    /**
     * 异常消息
     */
    private String msg ;


    public String getModule() {
        return module;
    }

    public String getCode() {
        return code;
    }

    public Throwable getThrowable() {
        return throwable;
    }

    public Object[] getArgs() {
        return args;
    }

    public String getMsg() {
        return msg;
    }

    /**
     * 使用枚举传参
     *
     * @param errorCode 异常枚举
     */
    public BusinessException(Throwable cause , CommonErrorCode errorCode) {
        super(errorCode.getMessage(),cause);
        this.code = errorCode.getCode();
    }

    public BusinessException(ExceptionEnum exceptionEnum) {
        this.msg = exceptionEnum.getMsg();
        this.code= exceptionEnum.getCode();
    }


    public BusinessException(String message) {
        this.msg = message;
        this.code= String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value());
    }


    public BusinessException(ExceptionEnum exceptionEnum ,Throwable throwable) {
        super(exceptionEnum.getMsg(),throwable);
        this.msg = exceptionEnum.getMsg();
        this.throwable = throwable;
        this.code= exceptionEnum.getCode();
    }


    public BusinessException(String message,Throwable throwable) {
        super(message,throwable);
        this.msg = message;
        this.throwable = throwable;
        this.code= String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value());
    }


    public BusinessException(String message,Throwable throwable,Object[] args) {
        super(message,throwable);
        this.msg = message;
        this.throwable = throwable;
        this.code= String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value());
        this.args= args;
    }



    public BusinessException(ExceptionEnum exceptionEnum, Throwable throwable, Object[] args) {
        super(exceptionEnum.getMsg(),throwable);
        this.msg = exceptionEnum.getMsg();
        this.code= exceptionEnum.getCode();
        this.throwable = throwable;
        this.args= args;
    }


    @Override
    public String getMessage() {
        return msg;
    }
}


package cn.com.wind.starter.log.model;

import cn.com.wind.starter.log.enums.CommonErrorCode;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.fastjson.serializer.SerializerFeature;

import java.io.Serializable;

/**
 * 返回统一数据结构
 */
public class Result<T> implements Serializable {


    /**
     * 服务器当前时间戳
     */
    private Long ts = System.currentTimeMillis();

    /**
     * 成功数据
     */
    private T data;

    /**
     * 错误码
     */
    private String code;

    /**
     * 错误描述
     */
    private String msg;


    private static final String Success = "1";



    public Long getTs() {
        return ts;
    }

    public void setTs(Long ts) {
        this.ts = ts;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }

    public Result() {

    }

    public Result( Long ts, T data, String code, String msg) {
        this.ts = ts;
        this.data = data;
        this.code = code;
        this.msg = msg;
    }

    public static Result<Void> ofSuccess() {
        Result<Void> result = new Result<>();
        result.setCode(Success);
        return result;
    }

    public static <T> Result<T> ofSuccess(T data) {
        Result<T> result = new Result<>();
        result.setData(data);
        result.setCode(Success);
        return result;
    }

    public static <T> Result<T> ofFail(String code, String msg) {
        Result<T> result = new Result<>();
        result.code = code;
        result.msg = msg;
        return result;
    }

    public static <T> Result<T> ofFail(String code, String msg, T data) {
        Result<T> result = new Result<>();
        result.code = code;
        result.msg = msg;
        result.setData(data);
        return result;
    }

    public static Result<String> ofFail(CommonErrorCode resultEnum) {
        Result<String> result = new Result<>();
        result.code = resultEnum.getCode();
        result.msg = resultEnum.getMessage();
        return result;
    }

    /**
     * 获取 json
     * @return json
     */
    public String buildResultJson() {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("code", this.code);
        jsonObject.put("ts", this.ts);
        jsonObject.put("msg", this.msg);
        jsonObject.put("data", this.data);
        return JSON.toJSONString(jsonObject, SerializerFeature.DisableCircularReferenceDetect);
    }

    @Override
    public String toString() {
        return "Result{" +
                ", ts=" + ts +
                ", data=" + data +
                ", code='" + code + '\'' +
                ", msg='" + msg + '\'' +
                '}';
    }
}
package cn.com.wind.starter.log.model;

import java.util.Date;

import com.fasterxml.jackson.annotation.JsonFormat;


public class SysOperLogDto {
    private static final long serialVersionUID = 1L;

    /** 日志主键 */
    private Long operId;

    /** 操作模块 */
    private String model;

    /** 业务类型（0其它 1新增 2修改 3删除） */
    private String businessType;

    /** 业务类型数组 */
    private Integer[] businessTypes;

    /** 请求方法 */
    private String method;

    /** 请求方式 */
    private String requestMethod;

    /** 操作类别（0其它 1后台用户 2手机端用户） */
    private String operatorType;

    /** 操作人员 */
    private String operName;

    /** 部门名称 */
    private String deptName;

    /** 请求url */
    private String operUrl;

    /** 操作地址 */
    private String operIp;

    /** 操作地点 */
    private String operLocation;

    /** 请求参数 */
    private String operParam;

    /** 返回参数 */
    private String jsonResult;

    /** 操作状态（0正常 1异常） */
    private String status;

    /** 错误消息 */
    private String errorMsg;

    /** 操作时间 */
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date operTime;


    /**
     * 持续时间
     */
    private String continueTime;


    /**
     * 操作系统
     */
    private String os;

    /**
     * 浏览器
     */
    private String  browser;

    public static long getSerialVersionUID() {
        return serialVersionUID;
    }

    public Long getOperId() {
        return operId;
    }

    public void setOperId(Long operId) {
        this.operId = operId;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public String getBusinessType() {
        return businessType;
    }

    public void setBusinessType(String businessType) {
        this.businessType = businessType;
    }

    public Integer[] getBusinessTypes() {
        return businessTypes;
    }

    public void setBusinessTypes(Integer[] businessTypes) {
        this.businessTypes = businessTypes;
    }

    public String getMethod() {
        return method;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public String getRequestMethod() {
        return requestMethod;
    }

    public void setRequestMethod(String requestMethod) {
        this.requestMethod = requestMethod;
    }

    public String getOperatorType() {
        return operatorType;
    }

    public void setOperatorType(String operatorType) {
        this.operatorType = operatorType;
    }

    public String getOperName() {
        return operName;
    }

    public void setOperName(String operName) {
        this.operName = operName;
    }

    public String getDeptName() {
        return deptName;
    }

    public void setDeptName(String deptName) {
        this.deptName = deptName;
    }

    public String getOperUrl() {
        return operUrl;
    }

    public void setOperUrl(String operUrl) {
        this.operUrl = operUrl;
    }

    public String getOperIp() {
        return operIp;
    }

    public void setOperIp(String operIp) {
        this.operIp = operIp;
    }

    public String getOperLocation() {
        return operLocation;
    }

    public void setOperLocation(String operLocation) {
        this.operLocation = operLocation;
    }

    public String getOperParam() {
        return operParam;
    }

    public void setOperParam(String operParam) {
        this.operParam = operParam;
    }

    public String getJsonResult() {
        return jsonResult;
    }

    public void setJsonResult(String jsonResult) {
        this.jsonResult = jsonResult;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }

    public Date getOperTime() {
        return operTime;
    }

    public void setOperTime(Date operTime) {
        this.operTime = operTime;
    }

    public String getContinueTime() {
        return continueTime;
    }

    public void setContinueTime(String continueTime) {
        this.continueTime = continueTime;
    }

    public String getOs() {
        return os;
    }

    public void setOs(String os) {
        this.os = os;
    }

    public String getBrowser() {
        return browser;
    }

    public void setBrowser(String browser) {
        this.browser = browser;
    }
}
package cn.com.wind.starter.log.prop;


import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(EagleSenderProperties.PREFIX)
public class EagleSenderProperties {

    public  final  static  String PREFIX  = "log.eagle";

    private String level;

    private Boolean globalSwitch =false;

    private Boolean send=false;

    public String getLevel() {
        return level;
    }

    public void setLevel(String level) {
        this.level = level;
    }

    public Boolean getGlobalSwitch() {
        return globalSwitch;
    }

    public void setGlobalSwitch(Boolean globalSwitch) {
        this.globalSwitch = globalSwitch;
    }

    public Boolean getSend() {
        return send;
    }

    public void setSend(Boolean send) {
        this.send = send;
    }
}
package cn.com.wind.starter.log.prop;

import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.ArrayList;
import java.util.List;

@ConfigurationProperties(GlobalDefaultProperties.PREFIX)
public class GlobalDefaultProperties {

    public static final String PREFIX = "log.dispose";

    private Integer errorMsgShowMaxCount = 5;

    /**
     * 统一返回过滤包
     */
    private List<String> adviceFilterPackage = new ArrayList<>();

    /**
     * 统一返回过滤类
     */
    private List<String> adviceFilterClass = new ArrayList<>();

    public List<String> getAdviceFilterPackage() {
        return adviceFilterPackage;
    }

    public void setAdviceFilterPackage(List<String> adviceFilterPackage) {
        this.adviceFilterPackage = adviceFilterPackage;
    }

    public List<String> getAdviceFilterClass() {
        return adviceFilterClass;
    }

    public void setAdviceFilterClass(List<String> adviceFilterClass) {
        this.adviceFilterClass = adviceFilterClass;
    }

    public static String getPREFIX() {
        return PREFIX;
    }

    public Integer getErrorMsgShowMaxCount() {
        return errorMsgShowMaxCount;
    }

    public void setErrorMsgShowMaxCount(Integer errorMsgShowMaxCount) {
        this.errorMsgShowMaxCount = errorMsgShowMaxCount;
    }
}


package cn.com.wind.starter.log.prop;

import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.ArrayList;
import java.util.List;

/**
 * @description: 日志切面中需在请求和响应中过滤日志的url
 * @date: 2022/3/7 15:55
 * @author: Riven Ge
 */

@ConfigurationProperties(prefix = "log.filter")
public class UrlFilterProperties {


    /**
     * 全局拦截开关
     */
    private Boolean globalSwitch = false;
    /**
     * 需过滤base64请求或相应的url
     */
    private List<String> bigDataUrls = new ArrayList<>();

    public Boolean getGlobalSwitch() {
        return globalSwitch;
    }

    public void setGlobalSwitch(Boolean globalSwitch) {
        this.globalSwitch = globalSwitch;
    }

    public List<String> getBigDataUrls() {
        return bigDataUrls;
    }

    public void setBigDataUrls(List<String> bigDataUrls) {
        this.bigDataUrls = bigDataUrls;
    }



}
package cn.com.wind.starter.log.service;

import cn.com.wind.starter.log.model.Result;

public interface InvokeExceptionService {


    Result<?> doSomeThingWithReturn(Exception  exception);

    void doSomeThing(Exception  exception);

    default Integer  handler(){
        return 1;
    };

}
package cn.com.wind.starter.log.utils;

import org.apache.commons.lang3.StringUtils;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;


/**
 * author:riven
 * 字符集工具类
 */
public class CharsetKit
{
    /** ISO-8859-1 */
    public static final String ISO_8859_1 = "ISO-8859-1";
    /** UTF-8 */
    public static final String UTF_8 = "UTF-8";
    /** GBK */
    public static final String GBK = "GBK";

    /** ISO-8859-1 */
    public static final Charset CHARSET_ISO_8859_1 = Charset.forName(ISO_8859_1);
    /** UTF-8 */
    public static final Charset CHARSET_UTF_8 = Charset.forName(UTF_8);
    /** GBK */
    public static final Charset CHARSET_GBK = Charset.forName(GBK);

    /**
     * 转换为Charset对象
     *
     * @param charset 字符集，为空则返回默认字符集
     * @return Charset
     */
    public static Charset charset(String charset)
    {
        return StringUtils.isEmpty(charset) ? Charset.defaultCharset() : Charset.forName(charset);
    }

    /**
     * 转换字符串的字符集编码
     *
     * @param source 字符串
     * @param srcCharset 源字符集，默认ISO-8859-1
     * @param destCharset 目标字符集，默认UTF-8
     * @return 转换后的字符集
     */
    public static String convert(String source, String srcCharset, String destCharset)
    {
        return convert(source, Charset.forName(srcCharset), Charset.forName(destCharset));
    }

    /**
     * 转换字符串的字符集编码
     *
     * @param source 字符串
     * @param srcCharset 源字符集，默认ISO-8859-1
     * @param destCharset 目标字符集，默认UTF-8
     * @return 转换后的字符集
     */
    public static String convert(String source, Charset srcCharset, Charset destCharset)
    {
        if (null == srcCharset)
        {
            srcCharset = StandardCharsets.ISO_8859_1;
        }

        if (null == destCharset)
        {
            srcCharset = StandardCharsets.UTF_8;
        }

        if (StringUtils.isEmpty(source) || srcCharset.equals(destCharset))
        {
            return source;
        }
        return new String(source.getBytes(srcCharset), destCharset);
    }

    /**
     * @return 系统字符集编码
     */
    public static String systemCharset()
    {
        return Charset.defaultCharset().name();
    }
}
package cn.com.wind.starter.log.utils;




import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.text.NumberFormat;
import java.util.Set;


/**
 * author:riven
 * 类型转换器
 */
public class Convert {


    /**
     * 转换为字符串<br>
     * 如果给定的值为null，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static String toStr(Object value, String defaultValue) {
        if (null == value) {
            return defaultValue;
        }
        if (value instanceof String) {
            return (String) value;
        }
        return value.toString();
    }

    /**
     * 转换为字符串<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static String toStr(Object value) {
        return toStr(value, null);
    }

    /**
     * 转换为字符<br>
     * 如果给定的值为null，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Character toChar(Object value, Character defaultValue) {
        if (null == value) {
            return defaultValue;
        }
        if (value instanceof Character) {
            return (Character) value;
        }

        final String valueStr = toStr(value, null);
        return StringUtils.isEmpty(valueStr) ? defaultValue : valueStr.charAt(0);
    }

    /**
     * 转换为字符<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Character toChar(Object value) {
        return toChar(value, null);
    }

    /**
     * 转换为byte<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Byte toByte(Object value, Byte defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Byte) {
            return (Byte) value;
        }
        if (value instanceof Number) {
            return ((Number) value).byteValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return Byte.parseByte(valueStr);
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为byte<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Byte toByte(Object value) {
        return toByte(value, null);
    }

    /**
     * 转换为Short<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Short toShort(Object value, Short defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Short) {
            return (Short) value;
        }
        if (value instanceof Number) {
            return ((Number) value).shortValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return Short.parseShort(valueStr.trim());
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为Short<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Short toShort(Object value) {
        return toShort(value, null);
    }

    /**
     * 转换为Number<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Number toNumber(Object value, Number defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Number) {
            return (Number) value;
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return NumberFormat.getInstance().parse(valueStr);
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为Number<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Number toNumber(Object value) {
        return toNumber(value, null);
    }

    /**
     * 转换为int<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Integer toInt(Object value, Integer defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Integer) {
            return (Integer) value;
        }
        if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return Integer.parseInt(valueStr.trim());
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为int<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Integer toInt(Object value) {
        return toInt(value, null);
    }

    /**
     * 转换为Integer数组<br>
     *
     * @param str 被转换的值
     * @return 结果
     */
    public static Integer[] toIntArray(String str) {
        return toIntArray(",", str);
    }

    /**
     * 转换为Long数组<br>
     *
     * @param str 被转换的值
     * @return 结果
     */
    public static Long[] toLongArray(String str) {
        return toLongArray(",", str);
    }

    /**
     * 转换为Integer数组<br>
     *
     * @param split 分隔符
     * @param split 被转换的值
     * @return 结果
     */
    public static Integer[] toIntArray(String split, String str) {
        if (StringUtils.isEmpty(str)) {
            return new Integer[]{};
        }
        String[] arr = str.split(split);
        final Integer[] ints = new Integer[arr.length];
        for (int i = 0; i < arr.length; i++) {
            final Integer v = toInt(arr[i], 0);
            ints[i] = v;
        }
        return ints;
    }

    /**
     * 转换为Long数组<br>
     *
     * @param split 分隔符
     * @param str   被转换的值
     * @return 结果
     */
    public static Long[] toLongArray(String split, String str) {
        if (StringUtils.isEmpty(str)) {
            return new Long[]{};
        }
        String[] arr = str.split(split);
        final Long[] longs = new Long[arr.length];
        for (int i = 0; i < arr.length; i++) {
            final Long v = toLong(arr[i], null);
            longs[i] = v;
        }
        return longs;
    }

    /**
     * 转换为String数组<br>
     *
     * @param str 被转换的值
     * @return 结果
     */
    public static String[] toStrArray(String str) {
        return toStrArray(",", str);
    }

    /**
     * 转换为String数组<br>
     *
     * @param split 分隔符
     * @param split 被转换的值
     * @return 结果
     */
    public static String[] toStrArray(String split, String str) {
        return str.split(split);
    }

    /**
     * 转换为long<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Long toLong(Object value, Long defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Long) {
            return (Long) value;
        }
        if (value instanceof Number) {
            return ((Number) value).longValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            // 支持科学计数法
            return new BigDecimal(valueStr.trim()).longValue();
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为long<br>
     * 如果给定的值为<key>null</key>，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Long toLong(Object value) {
        return toLong(value, null);
    }

    /**
     * 转换为double<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Double toDouble(Object value, Double defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Double) {
            return (Double) value;
        }
        if (value instanceof Number) {
            return ((Number) value).doubleValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            // 支持科学计数法
            return new BigDecimal(valueStr.trim()).doubleValue();
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为double<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Double toDouble(Object value) {
        return toDouble(value, null);
    }

    /**
     * 转换为Float<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Float toFloat(Object value, Float defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Float) {
            return (Float) value;
        }
        if (value instanceof Number) {
            return ((Number) value).floatValue();
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return Float.parseFloat(valueStr.trim());
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为Float<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Float toFloat(Object value) {
        return toFloat(value, null);
    }

    /**
     * 转换为boolean<br>
     * String支持的值为：true、false、yes、ok、no，1,0 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static Boolean toBool(Object value, Boolean defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        valueStr = valueStr.trim().toLowerCase();
        switch (valueStr) {
            case "true":
                return true;
            case "false":
                return false;
            case "yes":
                return true;
            case "ok":
                return true;
            case "no":
                return false;
            case "1":
                return true;
            case "0":
                return false;
            default:
                return defaultValue;
        }
    }

    /**
     * 转换为boolean<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static Boolean toBool(Object value) {
        return toBool(value, null);
    }

    /**
     * 转换为Enum对象<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     *
     * @param clazz        Enum的Class
     * @param value        值
     * @param defaultValue 默认值
     * @return Enum
     */
    public static <E extends Enum<E>> E toEnum(Class<E> clazz, Object value, E defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (clazz.isAssignableFrom(value.getClass())) {
            @SuppressWarnings("unchecked")
            E myE = (E) value;
            return myE;
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return Enum.valueOf(clazz, valueStr);
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为Enum对象<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     *
     * @param clazz Enum的Class
     * @param value 值
     * @return Enum
     */
    public static <E extends Enum<E>> E toEnum(Class<E> clazz, Object value) {
        return toEnum(clazz, value, null);
    }

    /**
     * 转换为BigInteger<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static BigInteger toBigInteger(Object value, BigInteger defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof BigInteger) {
            return (BigInteger) value;
        }
        if (value instanceof Long) {
            return BigInteger.valueOf((Long) value);
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return new BigInteger(valueStr);
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为BigInteger<br>
     * 如果给定的值为空，或者转换失败，返回默认值<key>null</key><br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static BigInteger toBigInteger(Object value) {
        return toBigInteger(value, null);
    }

    /**
     * 转换为BigDecimal<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value        被转换的值
     * @param defaultValue 转换错误时的默认值
     * @return 结果
     */
    public static BigDecimal toBigDecimal(Object value, BigDecimal defaultValue) {
        if (value == null) {
            return defaultValue;
        }
        if (value instanceof BigDecimal) {
            return (BigDecimal) value;
        }
        if (value instanceof Long) {
            return new BigDecimal((Long) value);
        }
        if (value instanceof Double) {
            return new BigDecimal((Double) value);
        }
        if (value instanceof Integer) {
            return new BigDecimal((Integer) value);
        }
        final String valueStr = toStr(value, null);
        if (StringUtils.isEmpty(valueStr)) {
            return defaultValue;
        }
        try {
            return new BigDecimal(valueStr);
        } catch (Exception e) {
            return defaultValue;
        }
    }

    /**
     * 转换为BigDecimal<br>
     * 如果给定的值为空，或者转换失败，返回默认值<br>
     * 转换失败不会报错
     *
     * @param value 被转换的值
     * @return 结果
     */
    public static BigDecimal toBigDecimal(Object value) {
        return toBigDecimal(value, null);
    }

    /**
     * 将对象转为字符串<br>
     * 1、Byte数组和ByteBuffer会被转换为对应字符串的数组 2、对象数组会调用Arrays.toString方法
     *
     * @param obj 对象
     * @return 字符串
     */
    public static String utf8Str(Object obj) {
        return str(obj, CharsetKit.CHARSET_UTF_8);
    }

    /**
     * 将对象转为字符串<br>
     * 1、Byte数组和ByteBuffer会被转换为对应字符串的数组 2、对象数组会调用Arrays.toString方法
     *
     * @param obj         对象
     * @param charsetName 字符集
     * @return 字符串
     */
    public static String str(Object obj, String charsetName) {
        return str(obj, Charset.forName(charsetName));
    }

    /**
     * 将对象转为字符串<br>
     * 1、Byte数组和ByteBuffer会被转换为对应字符串的数组 2、对象数组会调用Arrays.toString方法
     *
     * @param obj     对象
     * @param charset 字符集
     * @return 字符串
     */
    public static String str(Object obj, Charset charset) {
        if (null == obj) {
            return null;
        }

        if (obj instanceof String) {
            return (String) obj;
        } else if (obj instanceof byte[] || obj instanceof Byte[]) {
            return str((Byte[]) obj, charset);
        } else if (obj instanceof ByteBuffer) {
            return str((ByteBuffer) obj, charset);
        }
        return obj.toString();
    }

    /**
     * 将byte数组转为字符串
     *
     * @param bytes   byte数组
     * @param charset 字符集
     * @return 字符串
     */
    public static String str(byte[] bytes, String charset) {
        return str(bytes, StringUtils.isEmpty(charset) ? Charset.defaultCharset() : Charset.forName(charset));
    }

    /**
     * 解码字节码
     *
     * @param data    字符串
     * @param charset 字符集，如果此字段为空，则解码的结果取决于平台
     * @return 解码后的字符串
     */
    public static String str(byte[] data, Charset charset) {
        if (data == null) {
            return null;
        }

        if (null == charset) {
            return new String(data);
        }
        return new String(data, charset);
    }

    /**
     * 将编码的byteBuffer数据转换为字符串
     *
     * @param data    数据
     * @param charset 字符集，如果为空使用当前系统字符集
     * @return 字符串
     */
    public static String str(ByteBuffer data, String charset) {
        if (data == null) {
            return null;
        }

        return str(data, Charset.forName(charset));
    }

    /**
     * 将编码的byteBuffer数据转换为字符串
     *
     * @param data    数据
     * @param charset 字符集，如果为空使用当前系统字符集
     * @return 字符串
     */
    public static String str(ByteBuffer data, Charset charset) {
        if (null == charset) {
            charset = Charset.defaultCharset();
        }
        return charset.decode(data).toString();
    }

    // ----------------------------------------------------------------------- 全角半角转换

    /**
     * 半角转全角
     *
     * @param input String.
     * @return 全角字符串.
     */
    public static String toSBC(String input) {
        return toSBC(input, null);
    }

    /**
     * 半角转全角
     *
     * @param input         String
     * @param notConvertSet 不替换的字符集合
     * @return 全角字符串.
     */
    public static String toSBC(String input, Set<Character> notConvertSet) {
        char c[] = input.toCharArray();
        for (int i = 0; i < c.length; i++) {
            if (null != notConvertSet && notConvertSet.contains(c[i])) {
                // 跳过不替换的字符
                continue;
            }

            if (c[i] == ' ') {
                c[i] = '\u3000';
            } else if (c[i] < '\177') {
                c[i] = (char) (c[i] + 65248);

            }
        }
        return new String(c);
    }

    /**
     * 全角转半角
     *
     * @param input String.
     * @return 半角字符串
     */
    public static String toDBC(String input) {
        return toDBC(input, null);
    }

    /**
     * 替换全角为半角
     *
     * @param text          文本
     * @param notConvertSet 不替换的字符集合
     * @return 替换后的字符
     */
    public static String toDBC(String text, Set<Character> notConvertSet) {
        char c[] = text.toCharArray();
        for (int i = 0; i < c.length; i++) {
            if (null != notConvertSet && notConvertSet.contains(c[i])) {
                // 跳过不替换的字符
                continue;
            }

            if (c[i] == '\u3000') {
                c[i] = ' ';
            } else if (c[i] > '\uFF00' && c[i] < '\uFF5F') {
                c[i] = (char) (c[i] - 65248);
            }
        }
        String returnString = new String(c);

        return returnString;
    }

    /**
     * 数字金额大写转换 先写个完整的然后将如零拾替换成零
     *
     * @param n 数字
     * @return 中文大写数字
     */
    public static String digitUppercase(double n) {
        String[] fraction = {"角", "分"};
        String[] digit = {"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"};
        String[][] unit = {{"元", "万", "亿"}, {"", "拾", "佰", "仟"}};

        String head = n < 0 ? "负" : "";
        n = Math.abs(n);

        String s = "";
        for (int i = 0; i < fraction.length; i++) {
            s += (digit[(int) (Math.floor(n * 10 * Math.pow(10, i)) % 10)] + fraction[i]).replaceAll("(零.)+", "");
        }
        if (s.length() < 1) {
            s = "整";
        }
        int integerPart = (int) Math.floor(n);

        for (int i = 0; i < unit[0].length && integerPart > 0; i++) {
            String p = "";
            for (int j = 0; j < unit[1].length && n > 0; j++) {
                p = digit[integerPart % 10] + unit[1][j] + p;
                integerPart = integerPart / 10;
            }
            s = p.replaceAll("(零.)*零$", "").replaceAll("^$", "零") + unit[0][i] + s;
        }
        return head + s.replaceAll("(零.)*零元", "元").replaceFirst("(零.)+", "").replaceAll("(零.)+", "零").replaceAll("^整$", "零元整");
    }



}
package cn.com.wind.starter.log.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 日常日志
 */
public class ErrorLogUtils {

    private final static Logger log = LoggerFactory.getLogger(ErrorLogUtils.class);

    /**
     * 打印异常
     *
     * @param e 异常
     */
    public static void showError(Throwable e) {
        log.error(getErrorMsg(e, -1));
    }


    /**
     * 打印异常
     *
     * @param e   异常
     * @param row 打印行数
     */
    public static void showError(Throwable e, int row) {
        log.error(getErrorMsg(e, row));
    }

    /**
     * 获取异常消息
     *
     * @param e   异常
     * @param row 行数
     * @return 异常消息
     */
    public static String getErrorMsg(Throwable e, int row) {
        int i = 0;
        StringBuilder sb = new StringBuilder("\n").append(e.toString());
        for (StackTraceElement stackTraceElement : e.getStackTrace()) {
            if (row != -1 && row <= i) {
                break;
            }
            sb.append("\n").append("\t at ").append(stackTraceElement.toString());
            i++;
        }
        return sb.toString();
    }
}
package cn.com.wind.starter.log.utils;

import com.alibaba.fastjson.JSON;

public class FastJsonUtil {

    public static String toJson(Object o){
        return JSON.toJSONString(o);
    }
}
package cn.com.wind.starter.log.utils;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import org.apache.commons.lang3.StringUtils;

import java.util.Objects;
import java.util.Set;

/**
 * @description: 隐藏对象中的json
 * @date: 2022/3/8 11:35
 * @author: Riven Ge
 */

public class HideBigDataUtils {


    public static void hideJSONBigData(JSON o) {

        if (o instanceof JSONObject) {
            JSONObject o1 = (JSONObject) o;
            Set<String> keySet = o1.keySet();
            for (String key : keySet) {
                Object o2 = o1.get(key);
                if (o2 instanceof  String){
                    String string = o1.getString(key);
                    if (JSON.isValidObject(string)) {
                        JSONObject jsonObject = JSON.parseObject(string);
                        hideJSONBigData(jsonObject);
                        o1.put(key, FastJsonUtil.toJson(jsonObject));
                    } else if (JSON.isValidArray(string)) {
                        JSONArray jsonArray = JSON.parseArray(string);
                        hideJSONBigData(jsonArray);
                        o1.put(key, FastJsonUtil.toJson(jsonArray));
                    } else if (!isJSONString(string) && string.length() > 2000) {
                        o1.put(key, "******bigData******");
                    }
                }else if (o2 instanceof JSON){
                    hideJSONBigData((JSON) o2);
                    o1.put(key,o2);
                }

            }
        } else if (o instanceof JSONArray) {
            JSONArray array = (JSONArray) o;
            for (int i = 0; i < array.size(); i++) {
                Object o1 = array.get(i);
                String s = String.valueOf(o1);
                if (isJSONString(s)) {
                    hideJSONBigData((JSON) array.get(i));
                }else if (o1 instanceof String){
                    String s1 = hideNormalString(s);
                    if (!Objects.equals(s1,s)){
                        array.set(i, s1);
                    }
                }
            }
        }

    }

    public static boolean isJSONString(String str) {
        boolean result;
        try {
            Object obj=JSON.parse(str);
            JSON test = (JSON)obj;
            result = true;
        } catch (Exception e) {
            result=false;
        }
        return result;
    }

    public static Object hideObject(Object o){

            String s = String.valueOf(o);
            // 如果是对象
            if (!(o instanceof String) && !StringUtils.isNumeric(s)){
                s = JSONObject.toJSONString(o);
            }
            if (isJSONString(s)){
                Object parse = JSON.parse(s);
                hideJSONBigData((JSON) parse);
                return parse;
            }
            else if (!StringUtils.isNumeric(s)){
                return hideNormalString(s);
            }else {
                return o;
            }
    }


    public static String hideNormalString(String s) {

        if (s.length() > 2000) {
            return "******bigData******";
        }
        return s;
    }


}
package cn.com.wind.starter.log.utils;


import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.http.HttpMethod;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Enumeration;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @description: servlet工具类
 * @date: 2020/12/6 16:00
 * @author: ShangKun
 * @version: 2.0.0
 */

public class ServletUtil {

    /**
     * 获取String参数
     */
    public static String getParameter(String name)
    {
        return getRequest().getParameter(name);
    }

    /**
     * 获取String参数
     */
    public static String getParameter(String name, String defaultValue)
    {
        return Convert.toStr(getRequest().getParameter(name), defaultValue);
    }

    /**
     * 获取Integer参数
     */
    public static Integer getParameterToInt(String name)
    {
        return Convert.toInt(getRequest().getParameter(name));
    }

    /**
     * 获取Integer参数
     */
    public static Integer getParameterToInt(String name, Integer defaultValue)
    {
        return Convert.toInt(getRequest().getParameter(name), defaultValue);
    }

    /**
     * 获取request
     */
    public static HttpServletRequest getRequest()
    {

      return getRequestAttributes().getRequest();


    }

    /**
     * 获取response
     */
    public static HttpServletResponse getResponse()
    {
        return getRequestAttributes().getResponse();
    }

    /**
     * 获取session
     */
    public static HttpSession getSession()
    {
        return getRequest().getSession();
    }

    public static ServletRequestAttributes getRequestAttributes()
    {
        RequestAttributes attributes = RequestContextHolder.getRequestAttributes();
        return (ServletRequestAttributes) attributes;
    }

    /**
     * 将字符串渲染到客户端
     *
     * @param response 渲染对象
     * @param string 待渲染的字符串
     * @return null
     */
    public static String renderString(HttpServletResponse response, String string)
    {
        try
        {
            response.setStatus(200);
            response.setContentType("application/json");
            response.setCharacterEncoding("utf-8");
            response.getWriter().print(string);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 是否是Ajax异步请求
     *
     * @param request
     */
    public static boolean isAjaxRequest(HttpServletRequest request)
    {
        String accept = request.getHeader("accept");
        if (accept != null && accept.indexOf("application/json") != -1)
        {
            return true;
        }

        String xRequestedWith = request.getHeader("X-Requested-With");
        if (xRequestedWith != null && xRequestedWith.contains("XMLHttpRequest"))
        {
            return true;
        }

        String uri = request.getRequestURI();
        if (StringUtils.inStringIgnoreCase(uri, ".json", ".xml"))
        {
            return true;
        }

        String ajax = request.getParameter("__ajax");
        if (StringUtils.inStringIgnoreCase(ajax, "json", "xml"))
        {
            return true;
        }
        return false;
    }

    /**
     * 内容编码
     *
     * @param str 内容
     * @return 编码后的内容
     */
    public static String urlEncode(String str)
    {
        try
        {
            return URLEncoder.encode(str, "UTF-8");
        }
        catch (UnsupportedEncodingException e)
        {
            return "";
        }
    }

    /**
     * 内容解码
     *
     * @param str 内容
     * @return 解码后的内容
     */
    public static String urlDecode(String str)
    {
        try
        {
            return URLDecoder.decode(str, "UTF-8");
        }
        catch (UnsupportedEncodingException e)
        {
            return "";
        }
    }


    /**
     * 获取头信息
     * @return
     */
    public static Map<String, String> getHeaders()
    {

        HttpServletRequest request = getRequest();
        Map<String, String> map = new LinkedHashMap<>();
        Enumeration<String> enumeration = request.getHeaderNames();
        if (enumeration != null)
        {
            while (enumeration.hasMoreElements())
            {
                String key = enumeration.nextElement();
                String value = request.getHeader(key);
                map.put(key, value);
            }
        }
        return map;
    }


    /**
     * 获取头信息
     * @param headerName
     * @return
     */
    public static String getHeader(String  headerName)
    {
        HttpServletRequest request = getRequest();
        return  request.getHeader(headerName);
    }


    /**
     * 获得请求方式
     * @return
     */
    public static HttpMethod getRequestMethod(){
        return HttpMethod.valueOf(getRequest().getMethod());
    }


    /**
     * 获取用户真实IP地址，不使用request.getRemoteAddr();的原因是有可能用户使用了代理软件方式避免真实IP地址,
     *
     * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值，究竟哪个才是真正的用户端的真实IP呢？
     * 答案是取X-Forwarded-For中第一个非unknown的有效IP字符串。
     *
     * @param request
     * @return
     */
    public static String getIpAddress() {
        HttpServletRequest request = getRequest();
        String ip = request.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        String defaultIp = "0:0:0:0:0:0:0:1";
        final String localhostIp = "127.0.0.1";
        return ip.equals(defaultIp)?localhostIp:ip;
    }
}
package cn.com.wind.starter.log.utils;



import com.alibaba.fastjson.JSONObject;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.ObjectUtils;

import java.lang.reflect.Field;
import java.util.*;



/**
 * author:riven
 * 字符串工具类
 */
public class StringUtils extends org.apache.commons.lang3.StringUtils {


    public static final String EMPTY_JSON = "{}";
    public static final char C_BACKSLASH = '\\';
    public static final char C_DELIM_START = '{';
    public static final char C_DELIM_END = '}';


    /**
     * 空字符串
     */
    private static final String NULLSTR = "";

    /**
     * 下划线
     */
    private static final char SEPARATOR = '_';

    /**
     * 获取参数不为空值
     *
     * @param value defaultValue 要判断的value
     * @return value 返回值
     */
    public static <T> T nvl(T value, T defaultValue) {
        return value != null ? value : defaultValue;
    }

    /**
     * * 判断一个Collection是否为空， 包含List，Set，Queue
     *
     * @param coll 要判断的Collection
     * @return true：为空 false：非空
     */
    public static boolean isEmpty(Collection<?> coll) {
        return isNull(coll) || coll.isEmpty();
    }

    /**
     * * 判断一个Collection是否非空，包含List，Set，Queue
     *
     * @param coll 要判断的Collection
     * @return true：非空 false：空
     */
    public static boolean isNotEmpty(Collection<?> coll) {
        return !isEmpty(coll);
    }

    /**
     * * 判断一个对象数组是否为空
     *
     * @param objects 要判断的对象数组
     *                * @return true：为空 false：非空
     */
    public static boolean isEmpty(Object[] objects) {
        return isNull(objects) || (objects.length == 0);
    }

    /**
     * * 判断一个对象数组是否非空
     *
     * @param objects 要判断的对象数组
     * @return true：非空 false：空
     */
    public static boolean isNotEmpty(Object[] objects) {
        return !isEmpty(objects);
    }

    /**
     * * 判断一个Map是否为空
     *
     * @param map 要判断的Map
     * @return true：为空 false：非空
     */
    public static boolean isEmpty(Map<?, ?> map) {
        return isNull(map) || map.isEmpty();
    }

    /**
     * * 判断一个Map是否为空
     *
     * @param map 要判断的Map
     * @return true：非空 false：空
     */
    public static boolean isNotEmpty(Map<?, ?> map) {
        return !isEmpty(map);
    }

    /**
     * * 判断一个字符串是否为空串
     *
     * @param str String
     * @return true：为空 false：非空
     */
    public static boolean isEmpty(String str) {
        return isNull(str) || NULLSTR.equals(str.trim());
    }

    /**
     * * 判断一个字符串是否为非空串
     *
     * @param str String
     * @return true：非空串 false：空串
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }

    /**
     * * 判断一个对象是否为空
     *
     * @param object Object
     * @return true：为空 false：非空
     */
    public static boolean isNull(Object object) {
        return object == null;
    }

    /**
     * * 判断一个对象是否非空
     *
     * @param object Object
     * @return true：非空 false：空
     */
    public static boolean isNotNull(Object object) {
        return !isNull(object);
    }

    /**
     * * 判断一个对象是否是数组类型（Java基本型别的数组）
     *
     * @param object 对象
     * @return true：是数组 false：不是数组
     */
    public static boolean isArray(Object object) {
        return isNotNull(object) && object.getClass().isArray();
    }

    /**
     * 去空格
     */
    public static String trim(String str) {
        return (str == null ? "" : str.trim());
    }

    /**
     * 截取字符串
     *
     * @param str   字符串
     * @param start 开始
     * @return 结果
     */
    public static String substring(final String str, int start) {
        if (str == null) {
            return NULLSTR;
        }

        if (start < 0) {
            start = str.length() + start;
        }

        if (start < 0) {
            start = 0;
        }
        if (start > str.length()) {
            return NULLSTR;
        }

        return str.substring(start);
    }

    /**
     * 截取字符串
     *
     * @param str   字符串
     * @param start 开始
     * @param end   结束
     * @return 结果
     */
    public static String substring(final String str, int start, int end) {
        if (str == null) {
            return NULLSTR;
        }

        if (end < 0) {
            end = str.length() + end;
        }
        if (start < 0) {
            start = str.length() + start;
        }

        if (end > str.length()) {
            end = str.length();
        }

        if (start > end) {
            return NULLSTR;
        }

        if (start < 0) {
            start = 0;
        }
        if (end < 0) {
            end = 0;
        }

        return str.substring(start, end);
    }

    /**
     * 格式化文本, {} 表示占位符<br>
     * 此方法只是简单将占位符 {} 按照顺序替换为参数<br>
     * 如果想输出 {} 使用 \\转义 { 即可，如果想输出 {} 之前的 \ 使用双转义符 \\\\ 即可<br>
     * 例：<br>
     * 通常使用：format("this is {} for {}", "a", "b") -> this is a for b<br>
     * 转义{}： format("this is \\{} for {}", "a", "b") -> this is \{} for a<br>
     * 转义\： format("this is \\\\{} for {}", "a", "b") -> this is \a for b<br>
     *
     * @param template 文本模板，被替换的部分用 {} 表示
     * @param params   参数值
     * @return 格式化后的文本
     */
    public static String format(String template, Object... params) {
        if (isEmpty(params) || isEmpty(template))
        {
            return template;
        }
        return StrFormatter.format(template, params);
    }

    /**
     * l
     *
     * @param str 字符串
     * @param sep 分隔符
     * @return set集合
     */
    public static final Set<String> str2Set(String str, String sep) {
        return new HashSet<String>(str2List(str, sep, true, false));
    }








    /**
     * 字符串转list
     *
     * @param str         字符串
     * @param sep         分隔符
     * @param filterBlank 过滤纯空白
     * @param trim        去掉首尾空白
     * @return list集合
     */
    public static final List<String> str2List(String str, String sep, boolean filterBlank, boolean trim) {
        List<String> list = new ArrayList<String>();
        if (StringUtils.isEmpty(str)) {
            return list;
        }

        // 过滤空白字符串
        if (filterBlank && StringUtils.isBlank(str)) {
            return list;
        }
        String[] split = str.split(sep);
        for (String string : split) {
            if (filterBlank && StringUtils.isBlank(string)) {
                continue;
            }
            if (trim) {
                string = string.trim();
            }
            list.add(string);
        }

        return list;
    }


    /**
     * list转字符串
     * @param collection 字符串数组
     * @param sep 分隔符
     * @return
     */
    public static final String collect2str(Collection<String> collection, String sep) {

        if (isEmpty(collection)) {
            return "";
        }

        StringBuilder stringBuilder = new StringBuilder();

        for (String s : collection) {
            stringBuilder.append(s);
            stringBuilder.append(sep);
        }

        StringBuilder replace = stringBuilder.deleteCharAt(stringBuilder.length()-1);


        return replace.toString() ;
    }

    /**
     * 下划线转驼峰命名
     */
    public static String toUnderScoreCase(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        // 前置字符是否大写
        boolean preCharIsUpperCase = true;
        // 当前字符是否大写
        boolean curreCharIsUpperCase = true;
        // 下一字符是否大写
        boolean nexteCharIsUpperCase = true;
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            if (i > 0) {
                preCharIsUpperCase = Character.isUpperCase(str.charAt(i - 1));
            } else {
                preCharIsUpperCase = false;
            }

            curreCharIsUpperCase = Character.isUpperCase(c);

            if (i < (str.length() - 1)) {
                nexteCharIsUpperCase = Character.isUpperCase(str.charAt(i + 1));
            }

            if (preCharIsUpperCase && curreCharIsUpperCase && !nexteCharIsUpperCase) {
                sb.append(SEPARATOR);
            } else if ((i != 0 && !preCharIsUpperCase) && curreCharIsUpperCase) {
                sb.append(SEPARATOR);
            }
            sb.append(Character.toLowerCase(c));
        }

        return sb.toString();
    }

    /**
     * 是否包含字符串
     *
     * @param str  验证字符串
     * @param strs 字符串组
     * @return 包含返回true
     */
    public static boolean inStringIgnoreCase(String str, String... strs) {
        if (str != null && strs != null) {
            for (String s : strs) {
                if (str.equalsIgnoreCase(trim(s))) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * 将下划线大写方式命名的字符串转换为驼峰式。如果转换前的下划线大写方式命名的字符串为空，则返回空字符串。 例如：HELLO_WORLD->HelloWorld
     *
     * @param name 转换前的下划线大写方式命名的字符串
     * @return 转换后的驼峰式命名的字符串
     */
    public static String convertToCamelCase(String name) {
        StringBuilder result = new StringBuilder();
        // 快速检查
        if (name == null || name.isEmpty()) {
            // 没必要转换
            return "";
        } else if (!name.contains("_")) {
            // 不含下划线，仅将首字母大写
            return name.substring(0, 1).toUpperCase() + name.substring(1);
        }
        // 用下划线将原始字符串分割
        String[] camels = name.split("_");
        for (String camel : camels) {
            // 跳过原始字符串中开头、结尾的下换线或双重下划线
            if (camel.isEmpty()) {
                continue;
            }
            // 首字母大写
            result.append(camel.substring(0, 1).toUpperCase());
            result.append(camel.substring(1).toLowerCase());
        }
        return result.toString();
    }

    /**
     * 驼峰式命名法 例如：user_name->userName
     */
    public static String toCamelCase(String s) {
        if (s == null) {
            return null;
        }
        s = s.toLowerCase();
        StringBuilder sb = new StringBuilder(s.length());
        boolean upperCase = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            if (c == SEPARATOR) {
                upperCase = true;
            } else if (upperCase) {
                sb.append(Character.toUpperCase(c));
                upperCase = false;
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * 转换成UTF-8格式
     *
     * @param s
     * @return
     */
    public static String toUtf8String(String s) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c >= 0 && c <= 255) {
                sb.append(c);
            } else {
                byte[] b;
                try {
                    b = Character.toString(c).getBytes("utf-8");
                } catch (Exception ex) {
                    b = new byte[0];
                }
                for (int j = 0; j < b.length; j++) {
                    int k = b[j];
                    if (k < 0) {
                        k += 256;
                    }
                    sb.append("%" + Integer.toHexString(k).toUpperCase());
                }
            }
        }
        return sb.toString();
    }


    /**
     * 判断类中每个属性是否都为空
     *
     * @param o
     * @return
     */
    public static boolean allFieldIsNULL(Object o)  {

        for (Field field : o.getClass().getDeclaredFields()) {
            field.setAccessible(true);

            Object object = null;
            try {
                object = field.get(o);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
            // 如果是字符
            if (object instanceof CharSequence) {
                if (!ObjectUtils.isEmpty(object)) {
                    return false;
                }
            } else {
                if (null != object) {
                    return false;
                }
            }
        }

        return true;
    }


    /**
     * JSON字符串转化为map
     * @param jsonString json
     * @return
     */
    public static Map<String, Object> jsonStringToMap(String jsonString) {
        Map<String, Object> map = new HashMap<>();
        JSONObject jsonObject = JSONObject.parseObject(jsonString);
        for (Object k : jsonObject.keySet()) {
            Object o = jsonObject.get(k);
            if (o instanceof JSONObject) {
                // 如果内层是json对象的话，继续解析
                map.put(k.toString(), jsonStringToMap(o.toString()));
            } else {
                // 如果内层是普通对象的话，直接放入map中
                // map.put(k.toString(), o.toString().trim());
                if (o instanceof String) {
                    map.put(k.toString(), o.toString().trim());
                } else {
                    map.put(k.toString(), o);
                }
            }
        }
        return map;
    }



    /**
     * 查找指定字符串是否匹配指定字符串列表中的任意一个字符串
     *
     * @param str 指定字符串
     * @param strs 需要检查的字符串数组
     * @return 是否匹配
     */
    public static boolean matches(String str, List<String> strs)
    {
        if (isEmpty(str) || isEmpty(strs))
        {
            return false;
        }
        for (String pattern : strs)
        {
            if (isMatch(pattern, str))
            {
                return true;
            }
        }
        return false;
    }


    /**
     * 判断url是否与规则配置:
     * ? 表示单个字符;
     * * 表示一层路径内的任意字符串，不可跨层级;
     * ** 表示任意层路径;
     *
     * @param pattern 匹配规则
     * @param url 需要匹配的url
     * @return
     */
    public static boolean isMatch(String pattern, String url)
    {
        AntPathMatcher matcher = new AntPathMatcher();
        return matcher.match(pattern, url);
    }







    /**
     * 字符串格式化
     *
     */
    public static class StrFormatter
    {
        public static final String EMPTY_JSON = "{}";
        public static final char C_BACKSLASH = '\\';
        public static final char C_DELIM_START = '{';
        public static final char C_DELIM_END = '}';

        /**
         * 格式化字符串<br>
         * 此方法只是简单将占位符 {} 按照顺序替换为参数<br>
         * 如果想输出 {} 使用 \\转义 { 即可，如果想输出 {} 之前的 \ 使用双转义符 \\\\ 即可<br>
         * 例：<br>
         * 通常使用：format("this is {} for {}", "a", "b") -> this is a for b<br>
         * 转义{}： format("this is \\{} for {}", "a", "b") -> this is \{} for a<br>
         * 转义\： format("this is \\\\{} for {}", "a", "b") -> this is \a for b<br>
         *
         * @param strPattern 字符串模板
         * @param argArray 参数列表
         * @return 结果
         */
        public static String format(final String strPattern, final Object... argArray)
        {
            if (StringUtils.isEmpty(strPattern) || StringUtils.isEmpty(argArray))
            {
                return strPattern;
            }
            final int strPatternLength = strPattern.length();

            // 初始化定义好的长度以获得更好的性能
            StringBuilder sbuf = new StringBuilder(strPatternLength + 50);

            int handledPosition = 0;
            int delimIndex;// 占位符所在位置
            for (int argIndex = 0; argIndex < argArray.length; argIndex++)
            {
                delimIndex = strPattern.indexOf(EMPTY_JSON, handledPosition);
                if (delimIndex == -1)
                {
                    if (handledPosition == 0)
                    {
                        return strPattern;
                    }
                    else
                    { // 字符串模板剩余部分不再包含占位符，加入剩余部分后返回结果
                        sbuf.append(strPattern, handledPosition, strPatternLength);
                        return sbuf.toString();
                    }
                }
                else
                {
                    if (delimIndex > 0 && strPattern.charAt(delimIndex - 1) == C_BACKSLASH)
                    {
                        if (delimIndex > 1 && strPattern.charAt(delimIndex - 2) == C_BACKSLASH)
                        {
                            // 转义符之前还有一个转义符，占位符依旧有效
                            sbuf.append(strPattern, handledPosition, delimIndex - 1);
                            sbuf.append(Convert.utf8Str(argArray[argIndex]));
                            handledPosition = delimIndex + 2;
                        }
                        else
                        {
                            // 占位符被转义
                            argIndex--;
                            sbuf.append(strPattern, handledPosition, delimIndex - 1);
                            sbuf.append(C_DELIM_START);
                            handledPosition = delimIndex + 1;
                        }
                    }
                    else
                    {
                        // 正常占位符
                        sbuf.append(strPattern, handledPosition, delimIndex);
                        sbuf.append(Convert.utf8Str(argArray[argIndex]));
                        handledPosition = delimIndex + 2;
                    }
                }
            }
            // 加入最后一个占位符后所有的字符
            sbuf.append(strPattern, handledPosition, strPattern.length());

            return sbuf.toString();
        }
    }


}
cn.com.wind.starter.log.configuration.GlobalDefaultConfiguration
cn.com.wind.starter.log.configuration.MethodLogAutoConfiguration
<?xml version="1.0" encoding="utf-8"?>
<configuration status="INFO" monitorInterval="30" packages="cn.com.wind.starter.log.handler">
    <!-- 日志级别及优先级排序：OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL -->

    <Properties>
        <!--定义日志存储的路径-->
        <property name="FILE_PATH" value="./log/"/>
        <property name="FILE_NAME" value="SmartEditor"/>
    </Properties>

    <appenders>
        <Rewrite name="rewrite">
            <AppenderRef ref="Console"/>

            <SensitiveRewritePolicy/>
        </Rewrite>
        <Console name="stdout" target="SYSTEM_OUT">
<!--            <ThresholdFilter level="trace" onMatch="ACCEPT" onMismatch="DENY"/>-->
            <PatternLayout pattern="%date{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %level %X{TRACE_ID} %X{TRACE_QUESTION} [%file:%L] - %msg%n"/>
        </Console>


        <RollingFile name="RollingFileInfo" fileName="${FILE_PATH}/${FILE_NAME}.log"
                     filePattern="${FILE_PATH}/backup/info/${date:yyyy-MM}/${FILE_NAME}-%d{yyyy-MM-dd-HH}-%i.log.gz">
            <!-- 控制台对于 level以上的级别，接受(ACCEPT)，对于level以下的级别，拒绝(DENY) -->
            <ThresholdFilter level="info" onMatch="ACCEPT" onMismatch="DENY"/>
            <!-- use built-in lookups for system info or system properties -->
            <PatternLayout header="${java:runtime} - ${java:vm} - ${java:os}">
                <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %level %X{TRACE_ID} %X{TRACE_QUESTION} [%C{36}.%M] - %msg%n</Pattern>
            </PatternLayout>
            <Policies>
                <!-- 当 fileName 对应的日志大小超过100M时，会以filePattern 重新存入，并重新清空 fileName对应的日志-->
                <SizeBasedTriggeringPolicy size="100M"/>
                <TimeBasedTriggeringPolicy/>
            </Policies>
            <DefaultRolloverStrategy max="20">
                <!-- 每次滚动保留的文件数，目前配置按小时滚动，那么同一个小时内最大日志数为20 -->
                <Delete basePath="${FILE_PATH}/backup/info" maxDepth="100">
                    <!-- 删除 basePath及其子文件夹下 文件名符合glob 且超过7天的日志-->
                    <IfFileName glob="*/${FILE_NAME}.*.log.gz"/>
                    <!-- 保留日志天数 D H M S 分别对应天 小时 分钟 秒 -->
                    <IfLastModified age="7D"/>
                </Delete>
            </DefaultRolloverStrategy>
        </RollingFile>

        <RollingFile name="RollingFileError" fileName="${FILE_PATH}/${FILE_NAME}.error.log"
                     filePattern="${FILE_PATH}/backup/error/${date:yyyy-MM}/${FILE_NAME}-%d{yyyy-MM-dd-HH}-%i.log.gz">
            <ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/>
            <!-- use built-in lookups for system info or system properties -->
            <PatternLayout header="${java:runtime} - ${java:vm} - ${java:os}">
                <Pattern>%date{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %level %X{TRACE_ID} %X{TRACE_QUESTION} [%C{36}.%M] - %msg%n</Pattern>
            </PatternLayout>
            <Policies>
                <SizeBasedTriggeringPolicy size="100M"/>
                <TimeBasedTriggeringPolicy/>
            </Policies>
            <DefaultRolloverStrategy max="20">
                <!-- 每次滚动保留的文件数，目前配置按小时滚动，那么同一个小时内最大日志数为20 -->
                <Delete basePath="${FILE_PATH}/backup/error" maxDepth="100">
                    <IfFileName glob="*/${FILE_NAME}.*.log.gz"/>
                    <!-- 保留日志天数 D H M S 分别对应天 小时 分钟 秒 -->
                    <IfLastModified age="7D"/>
                </Delete>
            </DefaultRolloverStrategy>
        </RollingFile>
    </appenders>
    <loggers>
        <Root level="info">
            <appender-ref ref="stdout"/>
            <appender-ref ref="RollingFileInfo"/>
            <appender-ref ref="RollingFileError"/>
            <!--添加重写日志-->
            <AppenderRef ref="rewrite" />
        </Root>
        <logger name="org.springframework" level="info"/>
        <logger name="cn.com.wind.stock" level="debug"/>
    </loggers>
</configuration>

<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">

    <!-- 加载 Spring 配置文件信息 -->

    <conversionRule conversionWord="msg" converterClass="cn.com.wind.starter.log.handler.LogbackMessConverter" ></conversionRule>

    <springProperty scope="context" name="applicationName" source="spring.application.name" defaultValue="localhost"/>
    <!-- 日志存放路径 -->
    <property name="LOG_PATH" value="/var/log/tomcat/${applicationName}"/>

    <!-- 日志文件留守天数 -->
    <property name="LOG.MAX.HISTORY" value="30"/>

    <!-- 日志输出格式 -->
    <property name="LOG.CONSOLE.PATTERN"
              value="%d{yyyy-MM-dd HH:mm:ss} %highlight(%-5level) [${applicationName},%X{traceId:-tid},%X{userId:-uid},%X{requestChannel:-channel}] %boldYellow([%file:%method:%line]) [%thread] %-50logger{50} : %msg%n"/>
    <property name="FILE_LOG_PATTERN"
              value="%d{yyyy-MM-dd HH:mm:ss.SSS} [${applicationName},%X{traceId:-tid},%X{userId:-uid},%X{requestChannel:-channel}] [%level]- [%thread] - [%logger{56}:%method:%line] - %msg %n"/>

    <!-- 控制台输出 -->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG.CONSOLE.PATTERN}</pattern>
        </encoder>
    </appender>


    <!-- 系统日志输出 -->


    <appender name="DEBUG_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/debug.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${LOG_PATH}/debug.log.%d{yyyy-MM-dd}</fileNamePattern>
            <!-- 日志最大的历史 60天 -->
            <maxHistory>${LOG.MAX.HISTORY}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>DEBUG</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/info.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${LOG_PATH}/info.log.%d{yyyy-MM-dd}</fileNamePattern>
            <!-- 日志最大的历史 60天 -->
            <maxHistory>${LOG.MAX.HISTORY}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>INFO</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 系统日志输出 -->
    <appender name="WARN_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/warn.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${LOG_PATH}/warn.log.%d{yyyy-MM-dd}</fileNamePattern>
            <!-- 日志最大的历史 60天 -->
            <maxHistory>${LOG.MAX.HISTORY}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>WARN</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/error.log</file>
        <!-- 循环政策：基于时间创建日志文件 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志文件名格式 -->
            <fileNamePattern>${LOG_PATH}/error.log.%d{yyyy-MM-dd}</fileNamePattern>
            <!-- 日志最大的历史 60天 -->
            <maxHistory>${LOG.MAX.HISTORY}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!-- 过滤的级别 -->
            <level>ERROR</level>
            <!-- 匹配时的操作：接收（记录） -->
            <onMatch>ACCEPT</onMatch>
            <!-- 不匹配时的操作：拒绝（不记录） -->
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>


    <!-- 用户访问日志输出  -->
    <appender name="sys-user" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/sys-user.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 按天回滚 daily -->
            <fileNamePattern>${LOG_PATH}/sys-user.log.%d{yyyy-MM-dd}</fileNamePattern>
            <!-- 日志最大的历史 -->
            <maxHistory>${LOG.MAX.HISTORY}</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- 下面配置一些第三方包的日志过滤级别，用于避免刷屏 -->
    <logger name="org.hibernate" level="WARN"/>
    <logger name="org.springframework" level="WARN"/>
    <logger name="org.thymeleaf" level="WARN"/>
    <logger name="org.apache" level="WARN"/>

    <logger name="com.apache.ibatis" level="TRACE"/>
    <logger name="java.sql.Connection" level="DEBUG"/>
    <logger name="java.sql.PreparedStatement" level="DEBUG"/>
    <logger name="java.sql.Statement" level="DEBUG"/>
    <logger name="io.lettuce.core" level="WARN"/>
    <logger name="io.netty" level="WARN"/>


    <root level="INFO">
        <appender-ref ref="console"/>
        <appender-ref ref="INFO_FILE"/>
        <!--linux日志压缩策略不含此级别，打了容易让服务器空间不够-->
<!--        <appender-ref ref="WARN_FILE"/>-->
        <appender-ref ref="ERROR_FILE"/>
    </root>

    <!--系统用户操作日志-->
    <!--使用此方式记录private static final Logger logger = LoggerFactory.getLogger("sys-user");-->
    <logger name="sys-user" level="info">
        <appender-ref ref="sys-user"/>
    </logger>
</configuration>

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cn.com.wind</groupId>
    <artifactId>Wind.Common.Exception</artifactId>
    <version>1.1</version>


    <dependencies>
        <!--aop-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.2</version>
            <scope>provided</scope>
            <optional>true</optional>
        </dependency>

        <!--HttpRequest and  HttpResponse-->
<!--        <dependency>-->
<!--            <groupId>org.apache.tomcat.embed</groupId>-->
<!--            <artifactId>tomcat-embed-core</artifactId>-->
<!--            <version>9.0.78</version>-->
<!--            <scope>provided</scope>-->
<!--            <optional>true</optional>-->
<!--        </dependency>-->

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <version>2.5.5</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
            <version>2.5.5</version>
            <scope>provided</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>javax.persistence</groupId>
            <artifactId>persistence-api</artifactId>
            <version>1.0.2</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
            <version>2.13.5</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.validation</groupId>
            <artifactId>validation-api</artifactId>
            <version>1.1.0.Final</version>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.36</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.9</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.83</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.5.13</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.17.1</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.17.1</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
            <version>11.0.1</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>6.1.13</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-all</artifactId>
            <version>5.7.17</version>
            <optional>true</optional>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
            <version>3.4.0</version>
            <scope>compile</scope>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.2.1</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
